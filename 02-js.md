# Javascript Code Style

## Check List

#### ■ 引用

  - [x] 对所有的引用使用 const，确保你无法对引用重新赋值
  - [x] 如果你一定需要可变动的引用，使用 let
  - [x] 注意 let 和 const 都是块级作用域
  
#### ■ 对象

  - [x] 使用字面值创建对象   ```const item = {}```
  - [x] 如果你的代码在浏览器环境下执行，别使用 [保留字](http://es5.github.io/#x7.6.1) 作为键值。样的话在 IE8 不会运行。 
  - [x] 使用同义词替换需要使用的保留字。 ```good：style={} bad: class={}```
  - [x] 创建有动态属性名的对象时，使用可被计算的属性名称。
  - [x] 使用对象方法的简写。
  - [x] 使用对象属性值的简写。
  - [x] 在对象属性声明前把简写的属性分组。
  
#### ■ 数组
  - [x] 使用字面值创建数组。``const items = []```
  - [x] 向数组添加元素时使用 Arrary#push 替代直接赋值。
  - [x] 使用拓展运算符 `...` 复制数组。 ```const itemsCopy = [...items]```
  
#### ■ 解构
  - [x] 使用解构存取和使用多属性对象。解构能减少临时引用属性。
  - [x] 对数组使用解构赋值。
  - [x] 需要回传多个值时，使用对象解构，而不是数组解构。增加属性或者改变排序不会改变调用时的位置。
  
#### ■ Strings
  - [x] 字符串使用单引号 `''`
  - [ ] 字符串超过 80 个字节应该使用字符串连接号换行。
  - [ ] 注意 let 和 const 都是块级作用域
  - [x] 程序化生成字符串时，使用模板字符串代替字符串连接。

#### ■ 函数
  - [x] 使用函数声明代替函数表达式。
  - [x] 永远不要在一个非函数代码块（`if`、`while` 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。
  - [ ] **注意:** ECMA-262 把 `block` 定义为一组语句。函数声明不是语句。[阅读 ECMA-262 关于这个问题的说明](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97)。
  - [x] 永远不要把参数命名为 `arguments`。这将取代原来函数作用域内的 `arguments` 对象。
  - [x] 不要使用 `arguments`。可以选择 rest 语法 `...` 替代。使用 `...` 能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 `arguments` 是一个类数组。
  - [x] 直接给函数的参数指定默认值，不要使用一个变化的函数参数。
  - [ ] 直接给函数参数赋值时需要避免副作用。因为这样的写法让人感到很困惑。
    
#### ■ 箭头函数
  - [x] 当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。因为箭头函数创造了新的一个 `this` 执行环境.
  - [x] 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 `return` 都省略掉。如果不是，那就不要省略。
  
#### ■ 构造器
  - [x] 总是使用 `class`。避免直接操作 `prototype` 。
  - [x] 使用 `extends` 继承。
  - [x] 方法可以返回 `this` 来帮助链式调用。
  - [x] 可以写一个自定义的 `toString()` 方法，但要确保它能正常运行并且不会引起副作用。
  
#### ■ 模块
  - [x] 总是使用模组 (`import`/`export`) 而不是其他非标准模块系统。你可以编译为你喜欢的模块系统。
  - [x] 不要使用通配符 import。
  - [x] 不要从 import 中直接 export。

#### ■ Iterators and Generators
  - [ ] 不要使用 iterators。使用高阶函数例如 `map()` 和 `reduce()` 替代 `for-of`。这加强了我们不变的规则。处理纯函数的回调值更易读，这比它带来的副作用更重要。
  - [ ] 
  
#### ■ 属性
  - [x] 使用 `.` 来访问对象的属性。
  - [x] 当通过变量访问属性时使用中括号 `[]`。
  
#### ■ 变量
  - [x] 一直使用 `const` 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。[地球队长](http://www.wikiwand.com/en/Captain_Planet)已经警告过我们了。（译注：全局，global 亦有全球的意思。地球队长的责任是保卫地球环境，所以他警告我们不要造成「全球」污染。）
  - [x] 使用 `const` 声明每一个变量。增加新变量将变的更加容易，而且你永远不用再担心调换错 `;` 跟 `,`。
  - [x] 将所有的 `const` 和 `let` 分组。当你需要把已赋值变量赋值给未赋值变量时非常有用。
  - [x] 在你需要的地方给变量赋值，但请把它们放在一个合理的位置。`let` 和 `const` 是块级作用域而不是函数作用域。
  
#### ■ Hoisting
  - [x] `var` 声明会被提升至该作用域的顶部，但它们赋值不会提升。`let` 和 `const` 被赋予了一种称为「[暂时性死区（Temporal Dead Zones, TDZ）](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)」的概念。这对于了解为什么 [type of 不再安全](http://es-discourse.com/t/why-typeof-is-no-longer-safe/15)相当重要。
  - [x] 匿名函数表达式的变量名会被提升，但函数内容并不会。
  - [x] 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。
  - [x] 函数声明的名称和函数体都会被提升。
  
#### ■ 比较运算符和等号
  - [x] 优先使用 `===` 和 `!==` 而不是 `==` 和 `!=`.
  - [x] 条件表达式例如 `if` 语句通过抽象方法 `ToBoolean` 强制计算它们的表达式并且总是遵守下面的规则：
     + **对象** 被计算为 **true**
     + **Undefined** 被计算为 **false**
     + **Null** 被计算为 **false**
     + **布尔值** 被计算为 **布尔的值**
     + **数字** 如果是 **+0、-0、或 NaN** 被计算为 **false**, 否则为 **true**
     + **字符串** 如果是空字符串 `''` 被计算为 **false**，否则为 **true**
  - [x] 判断条件，使用简写。 ```if (name) ```   ```if (collection.length)```
  
#### ■ 代码块
  - [x] 使用大括号包裹所有的多行代码块。
  - [x] 如果通过 `if` 和 `else` 使用多行代码块，把 `else` 放在 `if` 代码块关闭括号的同一行。
  
#### ■ 注释
  - [x] 使用 `/** ... */` 作为多行注释。包含描述、指定所有参数和返回值的类型和值。
  - [x] 使用 `//` 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。
  - [x] 给注释增加 `FIXME` 或 `TODO` 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 `FIXME -- need to figure this out` 或者 `TODO -- need to implemen

#### ■ 空白
  - [x] 使用 2 个空格作为缩进。
  - [x] 在花括号前放一个空格。
  - [x] 在控制语句（`if`、`while` 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。
  - [x] 使用空格把运算符隔开。
  - [x] 在文件末尾插入一个空行。
  - [x] 在使用长方法链时进行缩进。使用前面的点 `.` 强调这是方法调用而不是新语句。
  - [x] 在块末和新语句前插入空行。
  
#### ■ 逗号
  - [x] 行首逗号：**不需要**。
  - [x] 增加结尾的逗号: **需要**。这会让 git diffs 更干净。另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的[尾逗号问题](es5/README.md#commas)。

#### ■ 分号
  - [x] **不使用分号**
  
#### ■ 类型转换
  - [ ] 在语句开始时执行类型转换。 
  - [ ] 字符串： ```totalScore = String(this.reviewScore)```
  - [ ] 对数字使用 `parseInt` 转换，并带上类型转换的基数。
  - [ ] 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决[性能问题](http://jsperf.com/coercion-vs-casting/3)时，留个注释说清楚原因和你的目的。位运算符不方便阅读。
  - [ ] **注:** 小心使用位操作运算符。数字会被当成 [64 位值](http://es5.github.io/#x4.3.19)，但是位操作运算符总是返回 32 位的整数（[参考](http://es5.github.io/#x11.7)）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。[关于这个问题的讨论](https://github.com/airbnb/javascript/issues/109)。最大的 32 位整数是 2,147,483,647：
  - [ ] 布尔: ```const hasAge = Boolean(age)```
  
#### ■ 命名规则
  - [x] 避免单字母命名。命名应具备描述性。
  - [x] 使用驼峰式命名对象、函数和实例。
  - [x] 使用帕斯卡式命名构造函数或类。
  - [x] 不要使用下划线 `_` 结尾或开头来命名属性和方法。
  - [x] 别保存 `this` 的引用。使用箭头函数或 Function#bind。
  - [x] 如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。
  - [x] 当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。
  - [x] 当你导出单例、函数库、空对象时使用帕斯卡式命名。

#### ■ 存取器
  - [ ] 属性的存取函数不是必须的。
  - [ ] 如果你需要存取函数时使用 `getVal()` 和 `setVal('hello')`。
  - [ ] 如果属性是布尔值，使用 `isVal()` 或 `hasVal()`。
  - [ ] 创建 `get()` 和 `set()` 函数是可以的，但要保持一致。
  
#### ■ 事件
  - [x] 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。

#### ■ jQuery
  - [x] 使用 `$` 作为存储 jQuery 对象的变量名前缀。
  - [x] 缓存 jQuery 查询。
  - [x] 对 DOM 查询使用层叠 `$('.sidebar ul')` 或 父元素 > 子元素 `$('.sidebar > ul')`。 [jsPerf](http://jsperf.com/jquery-find-vs-context-sel/16)
  - [x] 对有作用域的 jQuery 对象查询使用 `find`。

## References


https://github.com/yuche/javascript

https://github.com/airbnb/javascript

#### ■详细
https://github.com/monstarlab-chengdu-product-factory/front-end-wiki/blob/master/03-test-finish-condition-detail.md